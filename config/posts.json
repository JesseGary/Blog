{
  "posts": [
    {
      "content": "大数据作为一门应用广泛的技术，在不同的应用场景下对其数据结构，处理实时性都有不同的需求，所以大数据技术的先驱们开发了许多不同的技术框架来满足不同的需求。本章主要介绍大数据所采用的的主流处理框架以及其技术细节。\r\n<!-- more -->\r\n\r\n\r\n- 大数据处理工具分类\r\n  ![](http://doc.xr1228.com//post-images/1581042442307.PNG)\r\n\r\n\r\n# 一、几个重要的概念\r\n\r\n### 大数据技术的几个重要的观点，这个也是贯穿在整个大数据技术的重要思想\r\n\r\n- 分布式：数据存储于成百上千个服务器中\r\n- 大数据块：大数据块减少元数据的开销\r\n- 失败无法避免：使用商用硬件 → 失败是不可避免的，所以买便宜的硬件\r\n- 简洁的才是稳定的：简洁的一致性模型（单写者，避免相互等待）\r\n\r\n\r\n### 数据并行化（DLP）\r\n- 若干硬盘上的大量数据，可以被并行化的操作（比如，操作文档） Embarrassingly Parallel\r\n\r\n这是什么意思呢？将数据分隔成不同的，相互无关的数据块就能实现数据并行化。我们举个例子：\r\n\r\n**词频统计**   从多个数据中找到dog的发生次数，我们只需要把数据分成不同的块，同时进行查找，没找到一个dog，就返回一次结果。这样就能显著提高查找效率，这也是一种很朴实的观点。\r\n\r\n![](http://doc.xr1228.com//post-images/1581043388967.PNG)\r\n\r\n但是这样的解决方案也衍生了两个问题：\r\n- 共享的状态\r\n    - 吞吐量（多个进程同时改变）\r\n    - 同步（同时修改需要锁）\r\n- 小粒度的通信让元数据管理变得复杂\r\n\r\n为了解决这样的问题，我们将每个数据块看做一个单元，每个单元全部数完后将结果一次性返回。\r\n看似很美好，但是又又又衍生出两个问题：\r\n\r\n- 失败的机器（某个机器发生错误无法及时发现异常）\r\n- 共享的状态太大（返回的数据量太大）\r\n\r\n所以我们将全局状态也作为分布式状态，并且将每个数据块的存储状态保存下来。这样就满足了分布式处理的需求。\r\n![](http://doc.xr1228.com//post-images/1581059591932.PNG)\r\n\r\n> 以上提到的设计理念，就是MapReduce的设计理念。接下来我将对MapReduce进行详细介绍。\r\n\r\n# 二、MapReduce\r\n\r\n### MapReduce Process —— 数据并行的分治策略\r\n- Map\r\n    - 将数据分割为shards或者splites，将它们分配给工作节点，将工作节点来计算子问题的解。\r\n- Reduce\r\n    - 收集，合并子问题的解\r\n- 易于使用\r\n    - 开发者可以集中解决数据处理的问题\r\n    - MapReduce系统负责解决其他细节\r\n  \r\n  > MapReduce是很早就提出的想法，是算法设计中常用的策略。但是其技术特点非常符合大数据的技术需求，很好的解决了大数据系统的需求，让开发者集中精力进行数据处理，而不用考虑数据内部的细节。\r\n\r\n  ### MapReduce 的基本编程模型\r\n\r\n- Map\r\n    - map（in_key，in_value） → list（out_key,intermediate value)\r\n        - 处理输入的键值对\r\n        - 生成中间结果集\r\n- Reduce\r\n    - reduce(out_key,list(intermediate_value)) → list(out_value)\r\n        - 对于某个键，合并他所有的值\r\n        - 生成合并后的结果值集合 \r\n\r\n例子： 词频统计\r\n\r\n![](http://doc.xr1228.com//post-images/1581060446962.PNG)\r\n\r\nMapReduce算法的程序实现是非常简洁的\r\n\r\n```C\r\nmap(String input_key,String input_value):\r\n    //input_key:document name\r\n    //input_value:document contents\r\n    local Count = CountLocally(input_value);\r\n    foreach count:\r\n        Emit(word,count); //Produce count of words\r\n\r\nreduce(String word,Iterator intermediate_values):\r\n    //word:the word(in the intermediate key);\r\n    //intermediate_value:a list of counts;\r\n    int result = 0;\r\n    for each v in intermediate_values;\r\n        result += v;\r\n    Emit(word,result);\r\n```\r\n\r\n![](http://doc.xr1228.com//post-images/1581060926629.PNG)\r\n\r\n### MapReduce 的执行步骤\r\n\r\n1. 将输入数据分隔成M块，在每块上分布式的调用map()\r\n    - 通常每个数据魁岸16MB或者64MB\r\n    - 取决于GFS的数据库大小\r\n2. 输入数据由不同的服务器并行处理\r\n3. 通过将中间结果分割成R块,对每块分布式的调用Reduce()\r\n\r\n- M和R的数量由用户指定\r\n    - M>>#servers,R>#servers\r\n    - 很大的M值有助于负载均衡,以及快速恢复\r\n    - 每个Reduce()调用,对应一个单独的输出文件,若依R值不应该太大\r\n\r\n![](http://doc.xr1228.com//post-images/1581061621076.PNG)\r\n\r\n![](http://doc.xr1228.com//post-images/1581061663957.PNG)\r\n\r\n\r\n### Map Recude的性能优化\r\n\r\n- MapReduce 冗余执行\r\n    - 整个任务完成时间是由最慢的节点决定的\r\n    - 解决方案:在接近结束时,生成冗余任务 → 用其他机器同样进行冗余任务\r\n        - 谁最先完成,谁获胜\r\n        - 也叫做\"投机\"(speculative)执行\r\n    - 影响:极大的缩短任务完成时间\r\n        - 资源消耗增加 3%,大型任务速度提高 30%\r\n\r\n> MapReduce所有的操作都是独立且幂等的,所以不存在同步性问题\r\n\r\n- MapReduce故障处理\r\n    - 计算节点故障\r\n        - 控制节点通过周期性的心跳来检测故障\r\n        - 重新执行\r\n    - 主节点故障\r\n        - 可以解决,但是目前还没有解决(控制节点故障可能性很低,所以就直接重启即可)\r\n    - 健壮性\r\n        - MapReduce论文报告:曾经丢失1800个节点中的1600个,但是任务仍然正确完成.\r\n\r\n# Hadoop ：MapReduce的开源实现\r\n\r\n### Hadoop MapReduce的基本架构\r\n\r\n> Hadoop不仅仅实现了文件分布式存储和MapReduce，还实现了一系列容错、资源远离等服务\r\n\r\n- JobTracker（Master）\r\n    - 接收MR作业\r\n    - 分配任务给Worker\r\n    - 监控任务\r\n    - 处理错误\r\n- TaskTracker（worker）\r\n    - 运行Map和Reduce任务\r\n    - 管理中间输出\r\n- Client\r\n    - 提交作业的界面\r\n    - 得到多样的状态信息\r\n- Task\r\n    - 一个独立的过程\r\n    - 运行Map/Reduce函数\r\n\r\n\r\n### Hadoop MR程序执行过程 1\r\n\r\n![](http://doc.xr1228.com//post-images/1581090883921.png)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
      "data": {
        "title": "【工业与大数据】大数据的主要处理框架与工具",
        "date": "2020-02-07 10:18:09",
        "tags": [],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "大数据作为一门应用广泛的技术，在不同的应用场景下对其数据结构，处理实时性都有不同的需求，所以大数据技术的先驱们开发了许多不同的技术框架来满足不同的需求。本章主要介绍大数据所采用的的主流处理框架以及其技术细节。\r",
      "fileName": "gong-ye-yu-da-shu-ju-da-shu-ju-de-zhu-yao-chu-li-kuang-jia-yu-gong-ju"
    },
    {
      "content": "为什么传统的NFS/AFS并不能满足大数据的需要？为什么GFS大名鼎鼎？它解决了什么样的问题？\r\n<!-- more -->\r\n# 一、Google文件系统\r\n\r\n- 为什么需要一个不同的分布式文件系统？\r\n    - 为了建立搜索引擎，需要存储互联网容量的数据，支持数据快速写入到分布式文件系统中\r\n    - 为了支持查询，需要对大量数据进行处理，需要建立**倒排索引**，需要对网页数据进行排序\r\n    - 所有的技术革新，都是业务驱动的，业务需求决定了Google 文件系统的开发\r\n\r\n- GFS中的具体需求\r\n    - 需要一个分布式文件系统能够存储大量的数据\r\n        - 这样的文件系统建立在大规模X86集群之上，这些节点是廉价的，并且系统的模块还会出错\r\n    - 现有的文件系统无法满足Google对于存储数据的需求\r\n        - 整个硬件中的许多模块会出现出错的情况，出错会同时发生\r\n        - 有大量的超大规模文件（多个网页合并成的大数据文件），文件大小会超过数百G\r\n    - 读写模式（优化考虑）：\r\n        - 文件系统读写大量是写入一次，多次读取的特性\r\n        - 写入并发，并发读取\r\n        - 延迟和带宽的考虑（高延迟，高带宽）\r\n\r\n# 二、如何设计Google文件操作系统\r\n\r\n- 几个目标\r\n    - 要做一个文件系统（目录树，文件读写），支持读写非常大的文件\r\n    - 充分利用资源（负载均衡，扩展性）\r\n    - 容错（不能因为少数的节点出错就停止工作）\r\n    - 系统简洁（复杂的系统在涉及到数千个节点的时候无法理解与控制）\r\n\r\n\r\n为了实现以上目标，Google给出了文件系统设计的基本设计：\r\n- 文件系统的基本设计\r\n    - 数据块：由于文件的规模十分庞大，文件将会被划分为多个大小为64MB的数据块进行存储，这个数据块的大小远远大于一般文件系统数据块的大小（64K）\r\n    - 性能设计：依据全局动态信息，自动调整数据在不同服务器中的存放，服务器存储利用率相似，负载动态调整\r\n    - 可靠性：为了保证数据的可靠性，数据通过副本的方式保存在多个节点中，一般保存在3个节点以上\r\n    - 系统设计简化：通过单个节点保存文件系统的元数据，这个节点被称为Master节点，主借点来协调整个系统的访问流程。\r\n\r\n\r\n# 三、分布式文件系统的设计\r\n![](http://doc.xr1228.com//post-images/1580957028720.PNG)\r\n\r\n- 文件系统的主节点（存储元数据）\r\n- 文件系统命名空间：将文件路径与chunk对应信息保存（chunkServer） \r\n- 应用程序发送请求后，Master节点返回chunkhandle，chunklocations的信息，应用程序根据以上信息访问对应服务器。\r\n\r\n# 四、GFS性能问题\r\n\r\n根据之前的设计，我们很明容易就能发现这样的文件系统可能会存在两个问题：\r\n- 所有的访问都会通过Master节点，可能会成为性能瓶颈\r\n- master节点发生异常后整个文件系统都会出现异常\r\n\r\n为解决以上问题：\r\n- 主服务器的性能负载问题（主要的问题）\r\n    - 客户端数据缓存，每次请求获取1000chunk的元数据，减少客户端与元数据信息交互\r\n    - 元数据服务器存储在内存中\r\n- 块服务器的负载均衡问题 \r\n    - 不能让一部分块服务器出现性能瓶颈 （chunkServer）\r\n    - 负载必须要进行动态调整\r\n- 块服务器的扩展性问题\r\n\r\n> 在GFS中，一个64M的数据块大约需要64B元数据。10PB数据约需要 10GB的元数据控件（很容易可以满足）\r\n\r\n# 五、GFS可靠性问题\r\n\r\n- 块服务器的可靠性问题\r\n    - 快服务器出现错误怎么办？ → master服务器发现块服务器不在线时，启动副本恢复\r\n    - 一个块服务器出现错误的时候，副本数目恢复所需要的时间 （不同的数据块从不同服务器并行恢复）\r\n- 主服务器的可靠性问题\r\n    - 内存数据的可恢复性（日志操作，快速恢复，定期硬盘快照）\r\n    - 单个节点主服务器的可恢复性 → 影子（shadow）服务器\r\n    - 影子节点仍然会出现错误 → 硬盘快照保存多个副本\r\n\r\n# 六、 GFS一致性要求\r\n- 三副本一致性的基本要求\r\n    - 目标：维持每一个数据块的三个副本完全一样\r\n    - 方法：出事数据块都没有数据，出事数据相同，之后以相同的操作顺序执行客户端的操作\r\n    - 手段：基于租期以及主要副本的顺序定义\r\n\r\n![](http://doc.xr1228.com//post-images/1580972371396.PNG)\r\n\r\n- GFS中写入操作对一致性的影响\r\n\r\n![](http://doc.xr1228.com//post-images/1580972774298.PNG)\r\n\r\n- GFS 放松的一致性\r\n    - 一致的（Consistent）：文件的三个副本一直\r\n    - 明确的（Defined）：反映了客户端的操作\r\n\r\n\r\n# 七、GFS的POSIX兼容性\r\n\r\n> GFS不是标准的文件系统，是建立在本地文件系统之上的应用层文件系统。GFS与标准的POSIX文件系统并不兼容，因此GFS上不能够运行程序，访问GFS需要一个客户端。\r\n\r\n- 在数据的读写上，GFS的POSIX不一致主要表现在以下两个方面：\r\n    - 数据读写： GFS增加了Append操作，由文件系统确定写入地址，这是POSIX所没有的\r\n    - 数据一致性：POSIX不兼容，GFS定义了自己的数据一致性模型\r\n\r\n> 兼容性哲学：通用的一般不是最优的策略\r\n\r\n# 八、GFS的垃圾收集\r\n\r\n- 垃圾收集\r\n    - 删除的数据不是直接从本地文件系统中删除，而是通过垃圾收集的方法，比传统的方法简单，并更加可靠\r\n    - 主服务器要日志记录删除操作，并将文件改名成隐藏的文件名\r\n    - 在系统负载不高的时候后台挥手隐藏的文件\r\n- 过期副本的删除\r\n    - 整个系统在节点失效，并重新加入的时候产生过期副本数据\r\n    - 通过检查数据库的版本来探测到过期副本\r\n\r\n# 总结\r\n\r\nGFS实际上是演示了如何在现代市场上可见的硬件水平上构建一个大规模的处理系统\r\n- 从设计上就内建错误容忍机制\r\n- 对大文件的优化，特别是数据追加以及读取\r\n- 不局限于现有的文件系统接口，为了应用进行接口的扩张\r\n- 尽量使用简化的设计，如单个主服务器single master，简化系统的结构，便于理解与维护\r\n  \r\n  GFS以及相关的开源等价软件包括HDFS，MooseFS等限制的部署都非常广泛，验证了这个结构的有效性。",
      "data": {
        "title": "【工业与大数据】GFS：Google文件系统",
        "date": "2020-02-06 10:26:12",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-gfsgoogle-wen-jian-xi-tong.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "为什么传统的NFS/AFS并不能满足大数据的需要？为什么GFS大名鼎鼎？它解决了什么样的问题？\r",
      "fileName": "gong-ye-yu-da-shu-ju-gfsgoogle-wen-jian-xi-tong"
    },
    {
      "content": "## 一、文件系统基础  \n</br>\n\n### 文件系统概述\n#### 为什么要有文件系统？\n需要介质保存一些永久的数据，停电后数据也可以长期保存\n#### 文件系统的名字空间，名字空间的操作\n在文件数节点上进行操作\n#### 文件系统中文件读写操作\n提供一些例如 open、read、write、close的操作函数\n- open 操作：将文件 offset = 0，并记录文件操作信息\n- close 操作：将文件从内存中删除\n- read 操作：从offset=0位置读取size大小的数据。\n  \n### 文件系统的设计\n#### 文件系统的下层接口\n- 磁盘的读写接口，磁盘中的地址\n#### 文件系统的上层接口\n- 文件树的组织\n- 文件数据的读写\n#### 文件系统最本质的功能：将文件名字翻译定位到一个具体的磁盘位置，进而可以完成文件的读写。  \n\n</br>\n\n\n### 文件系统接口标准化\n虚拟文件系统（VFS）是物理文件系统与服务之间的一个接口层，它对Linux的每一个文件系统的所有细节进行抽象，使得不同的文件系统在Linux核心以及系统中运行的其他进程看来，都是相同的。即调用VFS接口来调用不同的文件操作系统。\n</br>\n</br>\n### 文件系统的磁盘数据结构\n![](http://doc.xr1228.com//post-images/1580632535964.png)\n\n### 文件系统的讨论\n- 关于磁盘块大小的讨论\n    - 一个文件起码占用1个文件块的空间（选择磁盘块越小浪费越小）\n    - 每个磁盘块需要元数据进行描述（磁盘块越多，开销越大）\n    - 虽然磁盘物理特性决定了最小的读写单元512字节，但是目前多数文件系统选用4k磁盘块。（根据不同文件系统特点选择）\n\n- 文件系统的缓存\n    - 缓存能够加速的必要条件，时间局部性（经常访问）与空间局部性（附近的数据也需要访问）\n\n- 磁盘系统的优化策略\n    - 磁盘的顺序读写与随机读写：尽量让磁盘进行顺序读写（顺序读写100MB带宽，随机读写1MB带宽）\n    - 如何进行磁盘优化\n\n## 二、分布式文件系统\n\n- 分布式文件系统需要提供什么功能？\n    - 文件系统目录树\n    - 文件的读写\n- 分布式文件系统建立的基础要讨论的两个问题\n    - 是否直接面对磁盘？ \n        - 无需直接面对磁盘，而是使用每台机器的操作系统中的文件系统来操作磁盘\n        -  直接面对磁盘： SANFS 更高性能\n    - 分布式文件系统中的地址是什么？\n        - 无法直接定位到磁盘：先定位到机器，然后定位到磁盘\n\n> 分布式文件系统的本质功能：将一个以目录树表达的文件翻译为具体的节点，而到磁盘的定位则可以交给本地文件系统完成。\n\n## 三、分布式文件系统举例 NFS（网络文件系统）\n\n![](http://doc.xr1228.com//post-images/1580954964552.PNG)\n\n###NFS文件系统的扩展：AFS文件系统\nNFS系统只有一台服务器，通过一台服务器对文件进行定位，用户操作某一个文件时，其实是对Server上某个目录进行操作。\n\n![](http://doc.xr1228.com//post-images/1580955318970.PNG)\n\nAFS是放在广域网的分布式文件系统\n\n1. 当用户访问某个文件时，先访问根服务器 /afs\n2. 根服务器维护了下一级服务器 （pku,tsinghua,washington)\n3. 每一级服务器为用户返回下一级服务器地址\n4. 最后一步交给本地文件系统对具体文件操作\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】分布式文件系统",
        "date": "2020-02-02 16:14:41",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/gong-ye-yu-da-shu-ju-fen-bu-shi-wen-jian-xi-tong.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "gong-ye-yu-da-shu-ju-fen-bu-shi-wen-jian-xi-tong"
    },
    {
      "content": "### 云计算 Cloud Computing\n既指作为服务通过互联网提供的应用程序（SaaS模式），又指提供这些服务的，位于数据中心的硬件和系统软件（公用计算）\n- 云：数据中心硬件与软件\n- 公有云：用即用即付的模式，开放给大众实用的云\n- 私有云：一个企业或者组织内部的数据中心\n- 公用（utility）计算：给人以无限资源的错觉\n  \n（以上定义来自加州大学伯克利分校，RAD实验室，2009年2月）\n\n### 云计算商业模式的三大特点：\n- 按需服务\n- 资源池\n- 可测量的服务\n\n### 云计算发展的市场条件\n- 大规模的互联网应用（社交网络、多媒体）\n    - 规模经济\n    - 需求增长促进数据中心建设增长\n    - 无法预测的应用增长速度Zynga，Netflix\n- 大数据应用\n    - 日志分析\n    - 机器学习应用\n\n### 云计算的价值 ：提高数据资源利用率\n  \n![](http://doc.xr1228.com//post-images/1580138871978.png)\n![](http://doc.xr1228.com//post-images/1580138914955.png)\n\n### 云计算的分类\n根据提供抽象接口位于哪一层来分类\n- 指令集虚拟机（Amazon EC2，3Tera）\n- 运行时系统虚拟机（Microsoft Azure）\n- 框架型虚拟机（Google AppEngine，Force.com)\n- 折衷：灵活性/可移植性 VS “内置”功能\n  \n  ![](http://doc.xr1228.com//post-images/1580139074150.png)\n\n根据提供服务类型分类\n- SaaS 软件即服务 ——消费者使用提供商运行在云设施上的应用程序，基本无法控制程序或者基础架构。\n- PasS 平台即服务 ——消费者将自己编写的程序部署在云基础设施上，可以控制应用程序，但不能控制基础设施\n- IaaS 基础设施即服务 —— 提供处理、存储、网络和其他基础计算资源，消费者可以利用这些资源部署任意程序，包括操作系统或应用程序。\n\nGartner新技术炒作曲线\n\n![](http://doc.xr1228.com//post-images/1580139452341.png)\n",
      "data": {
        "title": "【工业与大数据】云计算的商业模式",
        "date": "2020-01-27 23:10:56",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/yun-ji-suan-de-shang-ye-mo-shi.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "yun-ji-suan-de-shang-ye-mo-shi"
    },
    {
      "content": "\n大数据这个词已经火热了很多年，似乎处处都存在着大数据的噱头，让我们回归本质，探讨一下大数据是什么？\n本文介绍了大数据技术细节以及相关背景的的一些概念。本文并未对大数据的相关知识进行总结，所以本文仅作为参考，无需详细阅读。\n<!-- more -->\n\n\n\n## 背景 为什么需要大数据？\n\n- 我们比以往产生**更多**且**更多样性**的数据\n- 我们比以往**更快的**产生数据\n- 这些数据具有其价值性\n\n针对以上三个基本原因，我们必须通过处理这些数据来提取其中的价值。\n\n然而处理这些大量的数据面临两个问题：\n\n- 大规模数据的存储\n- 大规模数据的分析\n\n这里我们举一个**例子**：早期的网络环境就如同一条小河，依河而居的人们世代通过抓鱼维生。这个时期鱼的数量有限、种类单一。人们只需要把鱼抓起来放到冰箱，想吃的时候直接拿出来烤就可以了。\n\n![](http://doc.xr1228.com//post-images/1579677299293.PNG)\n\n随着人类抓鱼的速度越来越快，抓鱼水平越来越高。人们抓到的鱼数量越来越大，种类越来越丰富。人们逐渐遇到了两个代表性的问题：\n\n- 冰箱放不下（存储不足）\n- 烹饪不过来（处理效率不足）\n\n如何解决这样的问题呢？\n\n1. 冰箱放不下：\n\n解决冰箱放不下无非两个思路。①换一个大一点的冰箱（**纵向扩展**）②多买几个冰箱（横向扩展）\n显然纵向扩展是难以实现的，存10000...条鱼需要多大的冰箱？\n横向扩展相对容易实现，鱼多的时候多买一些冰箱，搞一个冷库（**集群**）然后大家一起去存放鱼（**分布式存储**）\n然而随着冰箱越来越多（**集群规模扩大**），人们又单独做了一个账本（**元数据**），里面存储了每条鱼存放在冰箱什么位置的信息。\n\n2. 烹饪不过来：\n\n鱼越来越多，即使所有的鱼都能保存到冰箱中，但是只有一个厨师的话效率实在太低。\n不如多找几个厨师，大家一起烤（分布式计算）\n## \n所以说，大数据技术本质上用于解决 海量数据提取、存储、处理的一套技术，分布式是其主要实现思路。\n\n## 重要结论\n\n**学术界普遍认为大数据仍处于发展与创新的初始阶段**。大量数据的存储并不是大数据技术的主要问题甚至不是重要问题，非结构化的数据的快速处理与分析利用才是大数据要解决的最主要问题。\n\n**大数据是相对的**，大数据的概念也是不断变化的。（三十年前100M也是大数据）大数据是指用现有技术手段和软件难以快速处理的数据。今天的大数据主要强调数据的非结构性与实时处理的要求。\n\n**人是大数据中重要的环节，数据可视化是实现人的作用的主要工具** 大数据强调人通过数据可视化对大数据运算结果的再次分析与知识提炼，以便进行进一步的数据挖掘。\n\n** 大数据的四个特点：**\n- Volume 数据量大\n- Velocity 速度快\n- Variety 种类多样\n- Value 价值密度低\n\n\n# 一、云计算\n\n## 大数据对于系统架构的需求\n\n为了对应大数据的几个基本特点：Volume(数据量大) Velocity(产生速度快) Variety(种类多)  Value(价值密度低)。因为以上几个特点，大数据对于数据架构的需求如下：\n\n- 显示的需求\n    - 海量计算和存储  ➡️  数据量大\n    - 快速计算  ➡️  产生速度快\n- 隐式的需求\n    - 数据的快速传输  ➡️  产生速度快\n    - 灵活性  ➡️  种类多\n    - 低成本  ➡️  价值密度低\n\n## 大数据的核心设计理念\n\n- 并行化\n    -  并行请求\n    - 并行进程\n    - 并行指令\n    - 并行数据\n    - 硬件描述\n- 规模经济  例子：WSC（仓库规模的计算机） 用网络链接起来的计算和存储设备。实用相对同质的硬件和系统软件平台、共享相同的系统管理、运行相对小数目的超大型程序、通用的资源管理架构增强了灵活性。\n    - 主要部件\n        - 供电、制冷、建筑、网络、安全\n        - 存储、计算\n    - 优势\n        - 规模经济\n        - 提高使用率\n    - 挑战\n        - 能耗PUE = Total Energy/Computer Energy\n        - 运维\n- 虚拟化（抽象） 解决多租户、多应用使用的问题 \n  \n  > 计算机科学中的所有问题，都可以通过增加一个层次的间接(indirectiron)来解决，当然除了间接层次过多的问题 —— David Wheeler\n\n虚拟化的结果 —— 每个用户认为自己有一套自己的架构，而实际所有人共享相同的硬件资源。\n\n![](http://doc.xr1228.com//post-images/1579969064114.png)\n\n\n# 二、虚拟化技术\n### 为什么要虚拟化？\n传统的虚拟化的目的主要是为了分区与抽象\n- 分区 Partitioning\n    - 分享：打破一个大资源\n    - 服务器\n- 抽象 Abstraction\n    - 用一个指令集仿真另一个指令集（简而言之就是一种操作系统使用另外一种系统）\n  \n在云计算时代，虚拟化是为了资源池，安全，便于管理\n- 资源池\n    - 聚合：将多个资源结合起来\n    - 合一：利于存储\n    - 动态：快速分配（虚拟机）\n- 隔离：保护消费者隔离其他租客\n    - 例如虚拟专用网（VPN）\n- 便于管理\n    - 测试\n    - 机动性\n  \n### 数据中心虚拟化的三个重要内容\n- 计算虚拟化\n  - 主操作系统：运行在真实机器上\n  - 客户操作系统：运行在主操作系统之上\n  - Hypervisor：支持运行在多个虚拟机上的软件\n    - 类型1:运行在真实机器上，例如 Xen、VMWARE、ESXi\n    - 类型2:运行在主操作系统，例如 MS Virtual PC\n    - 类型0:1和2兼有，例如 Linux KVM\n- 存储虚拟化\n- 网络虚拟化\n\n### 服务器虚拟化考虑的三个问题\n- 指令集的翻译 二进制翻译\n    - 如何快速执行\n    - 如何执行需要更高权限的指令\n- I/O设备的仿真\n    - 如何让虚拟机操作系统访问不支持的硬件\n    - 如何保护I/O性能\n- 保护处理器的数据结构 **影子**处理器\n\n### 虚拟化的核心问题：内存的保护管理\n![](http://doc.xr1228.com//post-images/1580566550776.png)\n计算机的内存映射是由MMU进行管理，当计算机虚拟化后运行在计算机上的多个系统对于MMU的控制方式是内存保护管理的重要问题。目前的解决方式：\n- 半虚拟化：修改虚拟机操作系统，能不做操作就不要作\n- 影子页表：\n    - 拒绝客户操作系统对实际页表条目的任何访问\n    - 捕获访问请求，在软件中仿真\n- 硬件支持的虚拟化：\n    - 二级地址转表（SLAT）\n        - AMD AMD-V RVI\n        - Intel VT-x EPT\n  \n> MMU是Memory Management Unit的缩写，中文名是内存管理单元，有时称作分页内存管理单元（英语：paged memory management unit，缩写为PMMU）。它是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制。\n\n### 网络虚拟化\n#### 网络虚拟化的用途\n![](http://doc.xr1228.com//post-images/1580567311758.png)\n#### 网络虚拟化的举例 ： VLAN\n最简单的目标：提供单一的二层网络\n- 端口分数不同的VLAN\n- 多个VLAN共享一个端口\n    - Trunk模式\n    - VLAN标签（12bits）：特殊的包头\n    - 最多支持4096 VLAN\n- VLAN的优劣与解决方案\n    - 优势：标准，支持广泛，硬件成本低\n    - 劣势：只能支持4096个VLAN\n    - 新的标准：VxLAN\n        - 通过三层隧道实现\n        - 广播 -> 组播\n        - Virtual Tunnel End Ppoints（VTEPs）负责打包和接包\n#### 现代网络虚拟化技术：软件定义网络\n- 传统网络\n    - 控制面与数据面集成在同一个设备中\n    - 不同网络设备之间通过协议决定如何转发\n- 软件定义网络\n    - 控制面集中管理，放在服务器中\n    - 举例：OpenFlow协议，每一层交换机通过Controller确定数据流向\n  ![](http://doc.xr1228.com//post-images/1580614390079.png)\n    - 举例：Portland —— 大规模的虚拟二层网络的实现\n        - 大型2层网络的挑战\n            - 地址解析（ARP）：广播\n            - 路由：广播\n            - 转发：交换机要记住大量状态\n            - 根源：MAC地址不连续\n        - Portland实现\n            - 与位置相关的虚拟地址\n            - 通过SDN的地址解析\n                - 网络截获所有ARP广播\n                - 把无序的MAC地址改成与物理位置相关的地址\n                - 转发数据包\n                - 发给服务器之前，改回原来的MAC地址\n  #### 存储虚拟化\n  - 存储的意义\n    - 独立于数据位置\n        - 扩展性强，容量大\n        - 易于管理（磁盘可集中存储）\n        - 提升磁盘使用率\n    - 独立与物理存储技术\n        - 易于升级\n        - 可用性的优化（多路径访问、冗余）\n        - 易于维护（在线的后台备份、恢复）\n- 存储虚拟化的三类接口\n    - 块接口\n        - 本例块存储\n        - 远程块存储接口\n    - 文件接口\n        - 文件系统\n        - 网络文件系统（NFS，CIFS，HDFS）\n        - VFS\n    - 对象存储接口\n        - 亚马逊S3（基于http协议的REST接口）\n        - OpenStack Swift\n- 存储虚拟化的实现方式\n    - SAN 存储区域网络\n        - Storage Area Network\n        - 存储服务器通过专用网络链接，例如光纤通道（FC）\n    - NAS 网络附接存储\n        - Network attached storage（NAS）\n        - 存储服务器通过通用网络来访问，例如以太网\n### 总结\n- 优势\n    - 统一、抽象的接口隐藏了复杂的物理硬件\n    - 灵活，可以软件定义\n    - 易于管理，更容易保证安全\n- 问题\n    - 虚拟化有一定的资源开销\n    - 通常没有实现性能的隔离\n    - 过多层的抽象：如何调试 ？\n- 发展趋势：软件定义数据中心？\n    - 网络功能虚拟化\n        - 防火墙、入侵检测系统虚拟化\n    - 资源的管理和调度\n    - 其他资源的虚拟化：空调？供电？建筑？\n    - 目标：性能+灵活性+管理\n\n\n\n# 三、典型的云计算系统\n### 一个虚拟机的生命周期\n![](http://doc.xr1228.com//post-images/1580630632121.png)\n\n1. 用户通过界面或命令行向API发送 ‘create instance’\n2. API节点记录虚拟机信息，发送调度请求给调度器\n3. 调度器找到可用的计算节点，向计算节点发送‘vm provision’请求\n4. 计算节点通过虚拟机hypervisor启动虚拟机\n5. Hypervisor去**镜像存储服务**获取虚拟机磁盘镜像\n6. 计算节点向网络节点发信息，请求给新创虚拟机分配网络资源\n7. 网络节点通过配置虚拟交换机配置网桥、VLAN等，实现虚拟网络，并在数据库中记录网络信息\n8. 计算节点向虚拟存储服务要求新建虚拟磁盘卷，并通过iSCS协议挂载\n9. 用户通过界面查询虚拟机创建的结果\n\n> 以上操作是异步\n\n### 什么是一个好的云计算系统\n- 让用户彻底忘记底层的硬件（通过好的虚拟化和抽象，让用户忘记复杂的硬件与运算逻辑）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
      "data": {
        "title": "【工业与大数据】大数据基础",
        "date": "2020-01-23 23:59:47",
        "tags": [
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/da-shu-ju-de-ji-chu-jia-gou-yun-ji-suan.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "\n大数据这个词已经火热了很多年，似乎处处都存在着大数据的噱头，让我们回归本质，探讨一下大数据是什么？\n本文介绍了大数据技术细节以及相关背景的的一些概念。本文并未对大数据的相关知识进行总结，所以本文仅作为参考，无需详细阅读。",
      "fileName": "da-shu-ju-de-ji-chu-jia-gou-yun-ji-suan"
    },
    {
      "content": "接下来，让我们一起来完成一项具有一定实际价值的工作吧!\n\n在数据可视化领域，我们经常会使用**词云**来对文字中词语频率进行统计。网络当中也有许多类似[Wordle](http://www.wordle.net/) 、[图悦](http://www.picdata.cn/picdata/)图云生成网站。不过佛家有一句禅语：\n> 莫向外求，但从心觅\n\n我们可以片面的将这句话用在编程当中——双手敲过的代码才属于自己。 接下来就让我们通过Python自己编写一个词云生成器吧！\n\n首先是效果图，我节选了BOE(目前国内最大的面板生产企业)现任董事长在2018年全球创新合作伙伴峰会中的演讲，让词云通过分析这篇演讲稿来看看这位企业家为合作伙伴勾勒出的物联网蓝图是怎样的：\n![](http://doc.xr1228.com//post-images/1579701301281.png)\n\n服务、技术、创新这些词语在演讲中被大量提及，通过这样一张图片，就能对这篇演讲的大概内容有一定的了解。那么Python是如何生成这样一副文字大小颜色方向各异的复杂图片呢？\n其实十分简单，仍旧是老规矩，NoBB，Show Code！\n\n```python\n# 词云图\nimport matplotlib.pyplot as plt\nimport jieba\nfrom wordcloud import WordCloud\nfrom os import path\n\nlocalpath = path.dirname(__file__)  # 获取当前工作路径\n# 获取文件，注意这里要看编码格式\ntext = open(localpath+r'/words.txt', 'r', encoding='UTF-8').read()\n# 剪切单词\ntext_cut = jieba.cut(text)\n# 单词拼接\nresult = ' '.join(text_cut)\n# 生成次云图\nwc = WordCloud(\n    # 字体路径\n    font_path=localpath + r'/simhei.ttf',\n    # 背景颜色\n    background_color='white',\n    # 图片宽度\n    width=500,\n    height=350,\n    # 字体的大小\n    max_font_size=70,\n    min_font_size=5,\n)\n# 生成词云图片\nwc.generate(result)\nplt.imshow(wc)\nplt.axis('off')\nplt.show()\n```\n\n你一定很惊讶短短20多行代码就实现了词云这样复杂的功能。这都归功于Python丰富的各类库\n请允许我再次唠叨一下库的定义。\n\n- 所谓库就是Python提供的实现一类功能的具有目录层次结构的程序集合。\n\n简而言之，库就是Python提供给我们的，帮我们实现功能的工具包，每个工具包都能实现一个或者一类功能。本次程序我们用到了四个库：\n\n- matplotlib：Matplotlib是一个Python 2D绘图库，它能够快速辅助数据分析人员生成图表、直方图、功率谱、条形图、误差图、散点图。pyplot是Matplotlib的一个命令风格函数的集合，使matplotlib的机制更像 MATLAB，matplotlib的pyplot子库提供了和matlab类似的绘图API，方便用户快速绘制2D图表。\n- jieba：jieba是一种中文分词组建，他通过一定计算逻辑可以将一句完整的中文句子拆解成一个个词语。\n- wordcloud是Python用于构建词云的工具包，其功能强大，支持自定义词云各项参数。\n- path：这是Python标准库（自带的、无需安装的）中提供的用于文件访问、处理的库\n\n通过调用这些库的API，我们就能够很容易的实现词云这样复杂的图片。\n你肯定已经早早将程序敲到电脑中编译运行了，但是却出现了这样的错误：\n\n```cmd\n发生异常: ModuleNotFoundError\nNo module named 'matplotlib'\n```\n\n为什么呢？因为我们的程序中使用到了matplotlib、jieba、wordcloud这些外部库，外部库需要我们下载安装到自己电脑上才可以运行。坏消息是我们要下载三个库才能保证程序正常跑起来，好消息安装三个库非常容易！\n\n之前我们提到了包管理器，python内置了包管理器，使用包管理安装外部库的命令格式如下：\n\n```cmd\npip3 install SomePackage  \n```\n\n注意这里是pip3（在python进入3.X时代包管理应当使用pip3这个命令）\n\n接下来让我们开始安装所需的三个外部包。打开命令行程序（windows系统 开始➡️运行➡️cmd，MacOS系统使用终端）\n\n```cmd\npip3 install matplotlib  #安装matplotlib\n\npip3 install jieba  #安装jieba\n\npip3 install wordcloud  #安装wordcloud\n```\n\n不出意外的情况下这些包就都安装好了，如果安装过程中有疑问，最好百度/Google/dogedoge一下，善用搜索引擎。\n万事俱备只欠东风，接下来我们逐行对程序进行分析。\n\n```python\nimport matplotlib.pyplot as plt\n```\n\n- 这句话翻译成汉语很简单:引用matplotlib库的pyplot功能包，并将其命名为'plt'\n- matplotlib.pyplot 也可以写为  from matplotlib import pyplot这样的形式，这种形式我们在后面也会遇到，只需知道他的意思就是从matplotlib库中调用pyplot功能即可\n- 为什么要将其 as plt呢？ 很明显，就是因为 matplotlib.pyplot 太长了，后面我们要多次用到这个命令，索性给他起个名字，方便后续书写。这个名字可以随便命名（尽量符合驼峰命名规则）\n\n```python\nimport jieba\nfrom wordcloud import WordCloud\nfrom os import path\n```\n\n很简单，就是引入其他几个所需的库。（这里三个包都没有使用别名，因为本身长度就不长）\n\n```python\nlocalpath = path.dirname(__file__)  # 获取当前工作路径\n```\n\npython是一种若类型语言，所以我们定义变量“localpath”的时候并没有像其他编程语言一样 使用 string 类型符\n这句代码的意思是：定义一个变量“localpath”，给这个变量赋值为 当前工作路径。\n如何获取当前工作路径呢？使用的方法就是path.dirname(__file__)，这是Python os库中自带的方法，是不是非常方便？\n\n```python\n# 获取文件，注意这里要看编码格式\ntext = open(localpath+r'/words.txt', 'r', encoding='UTF-8').read()\n```\n\n这句话定义了一个变量 text，将工作目录下的 words.txt中的文字赋值给它。\n这里用到了一个 python的open()函数，open() 函数用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。\nopen()函数代码格式如下：\n\n```python\nopen(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)\n```\n\n- file: 必需，文件路径（相对或者绝对路径）。\n- mode: 可选，文件打开模式：只读，写入，追加等。我们采用了r模式，即默认文件访问模式。\n- buffering: 可选，设置缓冲，-1为采用系统默认缓存大小，0表示不使用，1表示使用，大于1的数字表示缓存区大小\n- encoding: 一般使用utf8（可以正常读取中文）\n- errors: 报错级别\n- newline: 区分换行符\n- closefd: 传入的file参数类型\n\n这个时候你可能有些疑惑🤔，道理都懂，但是为什么open()这个函数在这里要这样写？因为该教程的前半部分主要面向初学者，我们也没有经历过系统性的基础学习，这里对 编程语言中方法（函数）的调用进行说明。\n\n比如本例中 open(localpath+r'/words.txt', 'r', encoding='UTF-8') 这个语句\n\n- open()表示方法名，告知计算机我调用的是什么方法（函数）\n- open中所有内容，我们称之为参数，不同参数用\",\"分开。也就是说在本例中，我们调用open()方法，这个方法使用了三个参数\n- 第一个参数告知计算机文件的路径，localpath+r'/words.txt'  即工作目录下的words.txt文件\n- 第二个参数告知计算机我们采用 r 的模式读取文件（只读）\n- 第三个参数告诉计算机我们用的编码模式\n- 给方法定义参数的这个动作我们称之为 **传参**\n\n希望这样的解释能让你对编程工作中最基础最重要的 方法和参数有基本的理解。\n\n```python\n# 剪切单词\ntext_cut = jieba.cut(text)\n```\n\n这一句，我们调用了jieba的cut方法，将刚刚获取的文件内容text传如cut方法，这样jieba就将我们的text自动分词，分为一个一个单词组成的词组。最后将词组赋值给新定义的变量 text_cut\n\n```python\n# 单词拼接\nresult = ' '.join(text_cut)\n```\n\n这里有调用了一个join方法，传入我们的数组text_cut。什么意思呢？就是将这分好的一个个词语组合起来，使用空格隔开，组合成一个字符串。\n到这里，我们对于文章的处理就结束了，我们将原来的文章分成一个个词语，每个词语用空格隔开。为什么要这样处理呢？没有别的原因，就是因为我们后续调用的 wordcloud库就是这样规定的，他只能识别这样形式的数据。\n\n```python\n# 生成次云图\nwc = WordCloud(\n    # 字体路径\n    font_path=localpath + r'/simhei.ttf',\n    # 背景颜色\n    background_color='white',\n    # 图片宽度\n    width=500,\n    height=350,\n    # 字体的大小\n    max_font_size=70,\n    min_font_size=5,\n)\n# 生成词云图片\nwc.generate(result)\n```\n\n这里看似复杂，其实更加简单，我们调用了wordcould的方法，并在方法中传入若干参数，通过这些参数定义我们生成词云的样式。\n这里尤其需要注意 font_path=localpath + r'/simhei.ttf' 这一句必不可少，因为wordcloud必须知道自己使用的字体文件是什么样的才能正确生成词云。所以我们在工作目录中放入了一个simhei.ttf字体文件，方便wordcloud调用。\n\n这样我们的一个词云生成器 wc就定义好了，后续再调用 generate()方法并将处理好的数据变量result扔进去即可。\n\n```python\nplt.imshow(wc)\nplt.axis('off') \nplt.show()\n```\n\n词云做好了，如何让它显示出来？\n\n- 调用plt（就是开头引用的2D图像生成包）中imshow()方法将wc图片进行显示，\n- 调用plt.axis('off')让它不要生成坐标轴\n- 调用plt.show()方法使其显示出来。\n\n这样我们点击运行后一张词云图就显示出来了，注意工作目录中用到的 word.txt文件，simhei.ttf放在[github](https://github.com/Wuriqilang/WordCloud)中，你可以自行下载。如果不会使用github下载也没关系，自己在网上任意下一个ttf的字体文件，自己随便写一个word.txt文本文档放到我们写的python程序目录中即可。\n\n虽然我说的琐碎，但是在实际编写过程中相信你还是遇到许多问题，失败多次，各种环节出现奇葩的我没有提到的问题。\n没关系，多查多想多问。遇到问题，请在下方留言区留言\n\n[更多词云资料](https://zhuanlan.zhihu.com/p/27626809)\n[本例源代码](https://github.com/Wuriqilang/WordCloud)",
      "data": {
        "title": "【编程只是工具】Python实用手册03 词云",
        "date": "2020-01-22 21:53:45",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-shi-yong-shou-ce-03-ci-yun.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-shi-yong-shou-ce-03-ci-yun"
    },
    {
      "content": "虽然说学习一门语言，通常都是从命令行开始的。因为命令行涉及到的知识点最少，也不需复杂的功能依赖，初学者在命令行程序中很容易掌握各种语言的特性。但是这种相对枯燥乏味的学习方式很容易让人产生挫败感，花费数个小时研究学习后展示在我们眼前的就是冷冰冰的几行数字。所以让我们从 UI 编程开始学习，结合实际例子来快速入门吧。\n\n请在 VS Code 中新建一个.py 文件，输入以下内容。注意从现在开始，程序的输入切勿复制粘贴，自己敲进去代码和复制粘贴感觉是不同的！\n\n```python\nimport tkinter #引入Tkinter功能模块\n\nroot = tkinter.Tk() #实例化一个视窗对象\n\nmyLabel = tkinter.Label(root, text=\"Welcome to python's World\")  #在视窗对象中实例化一个Label对象\nmyLabel.pack() #将对象放在窗口中\n\nroot.mainloop()  # 进入主窗口消息循环\n```\n\n点击运行（F5）后,出现就出现了第一个属于你的 Python 视窗\n\n![](http://doc.xr1228.com//post-images/1579701131042.png)\n\n让我们来详细讲解以下这段代码：\n\n```python\nimport tkinter #引入Tkinter功能模块\n```\n\n什么叫做引入？什么叫做 Tkinter？\n\n- 引入：顾名思义，就是引用其他人写好的功能集（库）。这个功能有可能是 Python 内置的，也有可能是我们从包管理器下载来的。通过引入，我们就能用一行代码调用前人辛苦写好的功能，快速实现我们自己的需求。\n- Python 与包：Python 与包的关系，就如同工程师与设备的关系。今天工程师需要实现制作一个手机，那么我们就调来（引入）一个专门制作手机的机器，我不管这个机器是怎么造出来的，只要机器能生产出我们想要的手机即可。\n- 包管理器：接着上面的类比，工程师今天不想造手机了，想直接造人民币。但我们并没有现成的人民币制造机，怎么呢？我们进口一台人民币制造机就可以了。包管理器就是我们去进口机器的地方。——包管理器中存放着数以万计的凝聚力无数人心血的功能包，我们想要调用包管理器中的包时，只需要在命令行中输入“pip install ....(包的名字)“即可。 本例并未使用包管理器，后续我们会接触到。\n- Tkinter：Tkinter 模块(Tk 接口)是 Python 的标准 Tk GUI 工具包的接口。啥意思？就是说这就是一个 Python 中已经内置的专门用来画用户界面的包。\n\n所以说，这行代码乍看起来不明白，说白了就是调用一个用来画用户界面的包。\n\n```python\nroot = tkinter.Tk() #实例化一个视窗对象\n```\n\n如果你接触过其他编程语言，就会发现这条语句似曾相识却又有所不同。我们先来解释这几个刚看到的名词。\n\n- 对象：简而言之就是具有某些功能和特性的抽象化集合。面向对象的编程思想中，世间万物都可以抽象为对象。所谓“晓看天色暮看云，行也对象，坐也对象“。上述代码中的root，就是我们所需要的视窗对象，而tkinter.TK()，则是生成对象的方法。\n- 对象的实例化：其实举一个例子就很好懂。张无忌对对敌光明顶，想要使出一招乾坤大挪移，然而乾坤大挪移并不是一个实实在在的物体，怎么做呢？**他按照《九阳神功》的口诀，调用体内真气流转将乾坤大挪移激发出来。**这个过程就是**实例化**。\n\n![](http://doc.xr1228.com//post-images/1579701158947.gif)\n\n所以说, tkinter.TK() 就是九阳神功中运转乾坤大挪移的法门，root 则是我们实例化出得乾坤大挪移对象。只有将对象实例化后，我们才能操作他完来成一系列任务。\n\n希望前面的解释能让你能对编程世界中最常用的几个概念有所体会，事实上编程就如同搭积木一样，我们调用不同的积木，采用不同的组合最后实现自己的目的。在工业实践应用中，参与编程的工程师并不需要早早了解多么深刻的编程原理和数据结构，我们能够熟练使用这些积木，搭建出想要的城堡就够了。\n\n此时，视窗对象已经完成了实例化，我们希望这个视窗能够显示一个句子。所以我们要继续实例化出一个标签对象来承接我们的句子。所以我们用到了这样一条语句。\n\n```python\nmyLabel = tkinter.Label(root, text=\"Welcome to python's World\")  #在视窗对象中实例化一个Label对象\nmyLabel.pack() #将对象放在窗口中\n```\n\ntkinter.Label()就是生成Label对象的方法。而括号中的内容，则是**方法的传参**\n\n- 方法的传参：不要觉得这么多生词很难理解，其实简而言之，就是我们调用方法的时候，给定一些基本参数，让方法按照我们的设定执行。譬如我们调用了一个 \"做饭.鱼香肉丝()\"的方法，如果我们想要设定 肉300g,盐20g，在编程语言里就可以写成 “做饭.鱼香肉丝(肉=300，盐=20)“这样的形式。是不是很好理解呢？\n- 解释这条语句：为了实例化出一个标签对象，我们采用tkinter.Label()的方法，在这个方法中我们传入两个参数，\n  - 第一个参数：root。这是告诉这个方法，我们的Label是在root中生成的。\n  - 第二个参数：test。这是告诉这个方法，我们的Label要显示test中的内容。\n- myLable.pack():对象实例化出后还有一个重要步骤，就是让他显示出来，让Label显示出来的的方法是myLabel.pack().\n  \n**到这里你一定非常迷惑——为啥要这么写？我怎么可能记住这么多方法？**\n- 为啥要这么写？ ——这是tkinter的作者规定的，你按照他的规定写就好了，以后当你自己写方法的时候你也可以很方便的规定他。\n- 我怎么可能记住这么多方法？ —— “唯手熟尔”，当然装B的说法就是，这些常用的方法很好记的，不信你写几次就知道了。即使记不住也没关系，google以下即可。\n\n\n```python\nroot.mainloop()  # 进入主窗口消息循环\n```\n\n最后一句也很好理解，就是让我们的视窗对象在运行起来。\n\n希望这篇文章能对你有帮助，如果有任何疑问可以在下方评论区提出。",
      "data": {
        "title": "【编程只是工具】Python实用教程02  Python UI编程",
        "date": "2020-01-22 21:51:17",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-shi-yong-jiao-cheng-02-python-ui-bian-cheng.jpeg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python-shi-yong-jiao-cheng-02-python-ui-bian-cheng"
    },
    {
      "content": "让我们做一个小游戏吧,体会一下 Python 独特的魅力。\n<!-- more -->\n\n\n请在 VS Code 中新建一个.py 文件，或者是在命令行管理器中输入 Python（MacOS 输入 Python3）写入以下内容。\n\n```python\nprint('\\n'.join([''.join([('Chinese！'[(x-y)%8]if((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3<=0 else' ')for x in range(-30,30)])for y in range(15,-15,-1)]))\n```\n\n点击运行（F5）后,出现了一个中国心。是不是很有趣？将代码中 Chinese！ 修改为喜欢的姑娘的名字送给她吧！(注意必须是 8 个字符)\n\n![](http://doc.xr1228.com//post-images/1579701034908.png)\n\nPython 的魅力远不止于此,这段代码初学者还不需要明白是什么意思，让我们赶快进入到后面的学习吧！",
      "data": {
        "title": "【编程只是一种工具】Python实用教程01  一句话表白 ",
        "date": "2020-01-22 21:49:28",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python-jiao-cheng-01.png",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "让我们做一个小游戏吧,体会一下 Python 独特的魅力。",
      "fileName": "python-jiao-cheng-01"
    },
    {
      "content": "\n> 人生苦短，我用 Python。 ——鲁迅\n\n## 写在开头\n\n本文档专注于编程语言在工业领域的实际应用，以实例讲解为主，还原编程语言的工具属性。这里会主要告诉你一个“工具怎么用”、“为什么要用”，但是不会过多涉及到“工具如何制造”以及“怎么用才更好”的问题。\n\n## Why Python\n\n- **天生优雅：** Python 使用了极为优雅精炼的语法与程序结构，一个简单的程序 C与JAVA 可能需要200行，而Python仅仅需要20行。Python提供了大量语法糖（或许你曾在比较各种语言优劣时听过这个词）Python就是将许多复杂的代码实现转化为精炼优雅符合人类直觉的书写方式，实用Python写程序时就如同孩子在吃糖果。\n- **开箱即用：** Python 提供了极为完善的基础代码库，很多看似复杂的程序实现可能仅仅需要调用Python中的一两个方法。对于一些复杂的图形处理，数据分析仅仅需要引入一两个依赖就能调用前人写好的功能模块。\n- **无所不能：** 受益于Python目前的热度，这个已经走过30年岁月的语言焕发出了无穷的活力。Python能够胜任从数据库，网络编程，机器学习各方面的应用。\n\n## Python 安装\n\nPython安装请选择最新版本3.7，网上有许多安装教程，这里不再赘述。[Python安装](https://www.liaoxuefeng.com/wiki/1016959663602400/1016959856222624)\n\n## 选用的编辑器\n\n按照编者的使用习惯，这里推荐使用VS Code作为您的Python编辑器。VS Code有以下优点：\n\n- 开源，免费；\n- 自定义配置\n- 集成git\n- 智能提示强大\n- 支持各种文件格式（html/jade/css/less/sass/xml）\n- 调试功能强大\n- 各种方便的快捷键\n- 强大的插件扩展\n简而言之，掌握了VS Code，你不但可以如丝般顺滑的编写Python程序，你具有了编写前端网页，Nodejs，文档……的能力。这样一把由微软打造的神兵谁会不喜欢呢？ [vs Code官网](https://code.visualstudio.com/)\n\n## VS Code安装汉化插件\n\nVS code安装汉化插件非常简单，打开vs Code后，选择左侧菜单栏中的插件商店，输入Chinese后选择Chinese (Simplified) Language Pack for Visual Studio Code点击 Install 即可。\n\nVS Code有很多优秀的插件能够极大的拓展VS Code功能，但如果你是编程初学者，建议先不要安装，让我们将更多注意力放在Python本身，以后按照自己的需要逐步拓展VS Code功能。\n\n## 一些学习Python的资源\n\n- Python基础学习 [廖雪峰Python教程](https://www.liaoxuefeng.com/wiki/1016959663602400)\n- 实用Python脚本学习视频 [实用主义教你学Python脚本](https://www.bilibili.com/video/av45221676)\n- [Tkinter 做简单的窗口视窗](https://www.bilibili.com/video/av16942112)\n",
      "data": {
        "title": "【编程只是一种工具】Python实用教程   介绍",
        "date": "2020-01-22 21:45:15",
        "tags": [
          "python"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/python.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "python"
    },
    {
      "content": "\r\n## 一、为什么智能制造\r\n2016年7月，京东方的业务定位由一家半导体显示技术、产品和服务提供商转型为一家为信息交互和人类健康提供智慧端口产品和专业服务的物联网公司。在践行智能制造的过程中，我们开发了一套应用于京东方面板生产产线的设备智能监控系统。旨在消除设备监控死角，节约不良调查时间，减少工厂生产运营人力成本。将设备监控从“发现不良→调查设备→解决问题”的被动模式转化为”设备监控→预防不良”的主动模式。通过充分挖掘企业数据潜能，建立一套可视化、智能化的设备监控系统，将工程师从繁复的日常监控工作中解放出来,为公司运营提供长久动力。\r\n### 1.1 Array智造整体架构\r\n如何真正实现智能制造，将智能化生产应用于实际工厂运营当中来不同工厂有不同的思路。通过对我国智能制造试点示范项目进行分析，梳理出如下九种典型的智能制造新模式：\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567583134061-9095d2cc-1ced-4460-a1d0-b20f5a119eaa.png#align=left&display=inline&height=386&name=%E5%9B%BE%E7%89%87.png&originHeight=386&originWidth=587&size=118189&status=done&width=587)\r\n\r\n\r\n工厂的智能化程度取决于其对数据的利用程度。结合对京东方自动化程度以及实际生产制造模式，设计了一种以挖掘企业数据潜能为核心的智能制造模式。\r\n设备智能监控系统是一套建立在BOE工厂现有CIM系统基础上，以挖掘数据潜能为核心思路而设计的数据采集、处理、分析系统。这个系统由以下几个节点组成：\r\n1.设备端：高度信息化的设备实时信息发送给MES系统，通过EIS对信息格式进行统一。\r\n2.CIM端：通过MES、YMS、DFS、eMpa、SPC、BO等系统将生产信息，测试信息进行汇总处理，并提供端口供设备智能监控程序调用原始数据。\r\n3.监控端：智能监控程序将原始数据进行分析处理最后生成可视化程度、集成度高的信息反馈给工程师，并展示在Monitor看板，以便管理者掌握生产运营状态。\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567583254106-8d646a0c-d511-4e26-8363-63e59382842a.png#align=left&display=inline&height=320&name=%E5%9B%BE%E7%89%87.png&originHeight=320&originWidth=548&size=74161&status=done&width=548)\r\n\r\n\r\n所以说Array智造软件专注于应用层的开发，通过整合现有数据资源，通过软件来优化工程师工作效率，减少无用的重复的劳动。\r\n\r\n### 1.2 Array智造的基础 —— 数据\r\n本节重点介绍Array智造中的数据如如何获取的，并介绍了两个采集数据的软件。\r\n为了便于理解，下面将通过不同功能的的数据源获取方式来依次介绍Array智造的数据模块。\r\n#### 1.2.1 AOI Monitor的数据获取\r\nAOI Monitor在设计之初是单纯为日常Monitor工作服务的，所以采用了单一数据源 —— DFS\r\n\r\n- DFS 是公司提供的分布式文件存储服务，对于我们业务部门来说，其使用体验等同于共享。\r\n- 目前DFS 的统一访问地址是  10.120.8.52  账号是 dfssrv2\\cifsa  密码是 cifsa \r\n- 注意：AOI Monitor为访问Inform等常用功能开放了快捷方式，后续担当可以根据业务需求修改\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567584769308-57815052-ea59-4897-8f98-fb85eaaac450.png#align=left&display=inline&height=192&name=%E5%9B%BE%E7%89%87.png&originHeight=192&originWidth=226&size=7897&status=done&width=226)    ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567584583410-1027da76-f284-42dd-93d9-7359c56a053f.png#align=left&display=inline&height=178&name=%E5%9B%BE%E7%89%87.png&originHeight=178&originWidth=404&size=39133&status=done&width=404)\r\n#### 1.2.2 CD Monitor的数据获取\r\nCD Monitor的数据流是 CD设备→曝光机共享→Monitor软件  来进行的，其获取数据的手段都是通过FileGee软件，该软件会在后面重点介绍。 该部分由马晓宇负责，如由疑问联系马晓宇。\r\n#### 1.2.3 IM Monitor的数据获取\r\nIM Monitor的数据来源如下：\r\n\r\n- DFS   包含了用户查询的IM Monitor图片信息\r\n- FTP   IM监控电脑不能访问共享，所以提交Abnormal时会先将Abnormal数据传到\r\n> FTP://10.120.9.22/【7】IM Abnormal\r\n\r\n- 共享  所有的Abnormal图片都会在存储在新共享\r\n> \\\\10.120.21.123\\Photo共享\\42.Photo工程部工作优化小组\\Array智造\\MuraHistor\r\n\r\n\r\n所以IM Monitor的数据流向如下\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586067028-e975c41e-9c89-48cc-9b56-597a0626b153.png#align=left&display=inline&height=349&name=%E5%9B%BE%E7%89%87.png&originHeight=349&originWidth=1096&size=11649&status=done&width=1096)\r\n#### 1.2.4 THK Monitor\r\nTHK Monitor数据来源全部为共享，数据流如下\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586183451-5e1e7fb1-b0a9-4bbe-98a5-7f7866258f86.png#align=left&display=inline&height=121&name=%E5%9B%BE%E7%89%87.png&originHeight=121&originWidth=1053&size=6779&status=done&width=1053)\r\n值得注意的是THK共享近期没有进行维护，后续担当需要开启。\r\n#### 1.2.5 设备监控\r\n设备监控中所有的数据都是从设备ProcessData中获取的，当我们将ProcessData保存到共享中，Array智造软件就可以方便的对数据进行处理和展示。其数据流向如下：\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567586828504-61a29a83-9785-4c56-9734-d43c4a0895ce.png#align=left&display=inline&height=667&name=%E5%9B%BE%E7%89%87.png&originHeight=667&originWidth=1110&size=29880&status=done&width=1110)\r\n\r\n值得注意的是：每天设备的数据现在设备上使用FTP Ghost软件简单处理后再利用FileGee进行上传\r\n\r\n#### 1.2.6 不良监控\r\n不良监控为了将各台设备的AOI Trend和工艺相关联起来，采取了比较复杂的数据获取方式。\r\n其数据获取方式与设备监控数据获取类似，重点在于将设备的工艺数据与DFS的测试数据相结合起来。\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567589162513-c0c2b6b2-ecb0-45c2-a1e7-ee86bfdb0c17.png#align=left&display=inline&height=659&name=%E5%9B%BE%E7%89%87.png&originHeight=659&originWidth=1106&size=30516&status=done&width=1106)\r\n#### 1.2.7 产能监控\r\n产能监控数据获取与设备监控相同，请参考 6.2.5\r\n\r\n\r\n#### 1.2.8 数据处理软件 参考附件【14】\r\n不难发现，上述各种数据获取离不开两个软件 FileGee与FTP Ghost。 具体使用方法较为复杂，已经单独交接给相关担当，软件请参考附件【14】\r\n\r\n### 1.3  智能制造的具体实现\r\n本节将介绍各软件模块的功能与基本实现思路，便于后续担当对软件进行进一步开发与维护。\r\n\r\n#### 1.3.1 AOI Monitor\r\nAOI Monitor目的是简化工程师日常Monitor流程，方便数据信息获取与基本的不良调查，其功能必须配合DFS使用，即用户电脑要开启DFS权限。AOI Monitor主要功能与实现如下：\r\n**AOI Monitor部分**\r\n\r\n\r\n- 通过LotID查询所有测试过得工序\r\n- 点击相应工序后显示测试过得Glass并且计算Total，对于异常Total使用红色显示\r\n- 点击跳转到DFS后能快捷跳转到DFS中，便于工程师看图\r\n\r\n**Tracing工具部分**\r\n\r\n- 通过GlassID查询所有测试过的工序\r\n- 多工序匹配Tracing结果，已经抓图的显示匹配结果，有Defect未抓图显示粉色背景，没有抓图显示灰色\r\n\r\n这里着重说一下Tracing工具的实现方式：先通过Data文件夹将所有Defect点位获取，匹配后（匹配规则是如果两个工序的点 X+Y的差＜0.5um且Y的差<0.5认为这两个点能够匹配到）筛选出查询到的Defect点并到Image文件夹中根据坐标找相应的图片，将图片地址存储到数据列表中，最后通过一定规则显示出来。\r\n\r\n\r\n#### ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567588150931-63e193b6-bbd9-4e61-bc70-942ca4601f84.png#align=left&display=inline&height=220&name=%E5%9B%BE%E7%89%87.png&originHeight=823&originWidth=1130&size=415771&status=done&width=302)        ![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567588691160-49d5e579-b6bc-4cac-ac67-0d3662c67fa4.png#align=left&display=inline&height=223&name=%E5%9B%BE%E7%89%87.png&originHeight=823&originWidth=1138&size=231877&status=done&width=308)\r\n**Mapping工具**\r\n\r\n- 该功能尚未开发完成，目标是能够根据DefectCode对多张Glass，或者多个Lot或者一段时间内的defect进行Mapping，请后续担当继续开发，如有问题可以联系我。\r\n#### 1.3.2 IM Monitor\r\nIM Monitor主要功能与实现如下：\r\n\r\n- 通过LotID查询所有测试过得工序，并显示IM图片\r\n- IM图片查看时具有放大镜功能\r\n- 点击图片时自动计算点位与在LC机台上的位置\r\n- 点击发送Abnormal单跳转到Abnormal单界面，在Abnormal单可以输入不良点位，并对图片进行标注\r\n- 提交Abnormal单时自动计算，防止出现错误提交重复提交的情况\r\n- 提交后的Abnormal单自动保存到FTP并且同步到共享中，工程师打开软件可以看到之前开的Abnormal记录\r\n- 工程师可以对Abnormal单进行回复，回复后再记录界面显示回复情况，回复人等信息\r\n- 附加Mura管理手册，便于Monitor人员判断不良原因\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567589798924-4c6d99bc-c741-411a-bbef-00940806f74e.png#align=left&display=inline&height=923&name=%E5%9B%BE%E7%89%87.png&originHeight=923&originWidth=1239&size=116133&status=done&width=1239)\r\n#### 1.3.3  THK Monitor\r\n注：THK Monitor目的是统一管理膜厚数据，简化膜厚数据处理。\r\nTHK Monitor实现功能主要如下：\r\n\r\n- 从共享中中获取各设备测试历史，计算测试结果。 →**后续担当应该严格要求到班组将数据放入相应文件夹中**\r\n\r\n- 拖拽计算测试结果（支持用户把文件直接拖拽到软件中，自动计算）\r\n- 支持同时查看两次测试结果（3D/Cross可以放到一个界面）\r\n\r\n因为测试数据复杂，计算逻辑和可视化逻辑需要的步骤较多，目前THK Monitor不足之处：\r\n\r\n- 文件命名必须严格遵循命名规则 （详见5.1）\r\n\r\n- 对于3D的显示没有合适的Chart控件，所以没有显示三维图形。 →需要后续开发\r\n- \r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567648084311-11142500-65b7-4d1a-b92c-ae0f6e3de52d.png#align=left&display=inline&height=785&name=%E5%9B%BE%E7%89%87.png&originHeight=785&originWidth=1162&size=102181&status=done&width=1162)\r\n\r\n#### 1.3.4 设备管理系统\r\n设备管理系统承担着我们科室自动点检，设备状态监控，产能监控的重要使命。该部分需要详细介绍并后续担当重点优化与开发。\r\n##### 1.3.4.1 设备管理系统的两个软件版本\r\n为了优化设备的管理，在之前设备管理系统的基础上，开发了两个版本，他们在Array智造主界面的以下位置。\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567648651670-a55ae6b8-0281-4584-9d12-209cb0201242.png#align=left&display=inline&height=222&name=%E5%9B%BE%E7%89%87.png&originHeight=222&originWidth=1110&size=20182&status=done&width=1110)\r\n\r\n\r\n- 设备监控为旧版软件，包括了设备监控的绝大多数功能。\r\n- 设备管理为新版软件，包括了HoldList与自动点检、ProcssData查看等新功能\r\n\r\n**计划将旧版软件所有功能迁移到新版软件，但是时间有限，请后续担当继续推进。**\r\n##### 1.3.4.2 自动点检功能\r\n自动点检实现是将ProcessData中最新三张Glass数据与Spce表对比，如果其中有连续两张Glass都OutOfSPC，则提示设备参数异常。\r\n所以后续担当主要维护以下几点\r\n\r\n- 根据实际生产情况调整Spec\r\n- 根据实际生产情况设置报警逻辑\r\n- 根据工程师经验为每个参数设定调整建议和影响    \r\n\r\n同时自动点检功能为一些重点参数设定了快捷查看入口，对于TactTime也设立了可视化图表\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567649535066-521bef35-9c16-4555-8513-944b96f6c7fe.png#align=left&display=inline&height=825&name=%E5%9B%BE%E7%89%87.png&originHeight=825&originWidth=1354&size=175515&status=done&width=1354)\r\n\r\n##### 1.3.4.3 Tank监控\r\n为了避免Tank切换导致的批次性工艺不良，在主界面也可以显示目前PLN设备使用的Tank情况\r\n计算逻辑是：根据设备最近一张Glass使用Tank情况判断目前设备使用哪个Tank\r\n##### 1.3.4.4 VCD时间点检\r\n计算逻辑：根据设备最近几张Glass VCD工艺时间计算两个VCD Chamber的工艺时间差\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567649710578-67fa62aa-c044-4c18-8f1d-8f4920ac0a21.png#align=left&display=inline&height=493&name=%E5%9B%BE%E7%89%87.png&originHeight=493&originWidth=347&size=27243&status=done&width=347)\r\n\r\n\r\n##### 1.3.4.5 CD波动调查\r\n计算逻辑：根据设备ProcessData将某个Lot CD波动相关数据直观展示\r\n##### 1.3.4.6 Hold List\r\nHoldList实现逻辑相对较为复杂，具体实现方式\r\nBO自动发送邮件 → 通过OutLook功能自动下载附件至D盘→利用FileGee同步文件到共享→设备监控软件读取HoldList文件并筛选与Track相关Lot\r\n该功能重点在于邮箱附件的自动保存，但是这种方式费时费力还不好维护（OutLook的自动化功能也不稳定，后续我去CIM以后再进行修改吧）\r\n##### 1.3.4.7 自动化点检表\r\n为应对体系审核，需要对点检表进行自动生成，该功能放在设备管理系统中，具体交由王志敏维护，详见1.3.5\r\n##### 1.3.4.8 ProcessHistroy\r\n为便于查看ProcessData History，模仿产线内History功能。\r\n该功能未开发完成，有以下遗留问题：\r\n\r\n- 数据获取耗时较长，计算逻辑有待优化\r\n- 未加入可视化图表和数据筛选功能，需要进一步开发\r\n- \r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567650482748-27b87d01-0913-4f86-936f-92192ab25a6d.png#align=left&display=inline&height=981&name=%E5%9B%BE%E7%89%87.png&originHeight=981&originWidth=1303&size=65177&status=done&width=1303)\r\n\r\n#### 1.3.5 自动化点检表\r\n为应对体系检查，需要生成点检表。针对该问题开发功能如下：\r\n\r\n- 输入点检人，点击点检按钮对当日所有设备进行点检\r\n- 对于NG项目备注中提示NG原因，并提示已经调整OK\r\n- 点击保存点检结果后将点检数据保存到共享中\r\n- 点击SPEC设置，可以查看设定的Spec值，（暂未加入修改Spec功能，修改需要在共享中修改Txt文件）\r\n- 隐藏功能：选择StartTime→点击管理员功能  就可以实现从选择日期开始所有日期点检表的检查和保存\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567671153504-9972651b-53d9-427a-9855-720d91be2e91.png#align=left&display=inline&height=971&name=%E5%9B%BE%E7%89%87.png&originHeight=971&originWidth=1292&size=81412&status=done&width=1292)\r\n\r\n#### 1.3.6 不良监控系统\r\n为了优化不良调查流程，减少重复工作，开发了不良监控系统。\r\n目前实现功能如下：\r\n\r\n- 根据设备，日期，自动分析进行过的Lot，生成相关的Layer。\r\n- 根据用户选择的Layer，输入的Defect Code，生成Trend（时间按照Track进行Mask时间），Chamber别，Mapping结果。 （如果DefectCode输入所有不良，则刷取所有Code）\r\n- 支持切换DIPI和FIPI结果\r\n\r\n该功能仍有许多优化空间：\r\n\r\n- 目前尚未加入型号别刷取\r\n- 刷取速度很大一部分取决于电脑速度，可以通过更加优化的异步等方法优化。\r\n- 每次刷取是对时间和DFS资源的巨大负担，后续可以通过自动记录数据库的方式优化。（数据库已经进行过开发，但是受限于CS架构模式，暂时弃用）\r\n\r\n我们最终的目的是，10W左右的数据量能够在10s内显示出来，这必须依托于CS架构，所以我先去CIM学习了，后续开发可以联系我。\r\n\r\n#### 1.3.7 产能监控\r\n产能监控主要功能如下：\r\n\r\n- 根据用户选择设备，日期读取ProcessData，自动计算TactTime\r\n- 根据过滤条件选择计算相应TactTime\r\n- 计算cycleTime（但是cycleTime中部分EXP单元时间不正确，后续可以酌情调整）\r\n\r\n\r\n![图片.png](https://cdn.nlark.com/yuque/0/2019/png/332465/1567673699483-867c9f77-37a9-4c97-9d64-92738be78158.png#align=left&display=inline&height=771&name=%E5%9B%BE%E7%89%87.png&originHeight=771&originWidth=1240&size=101617&status=done&width=1240)\r\n\r\n#### 1.3.8 其他辅助功能\r\n智能制造中也开发了多项辅助功能，类似人工判图，Recipe自动生成等，请知悉。\r\n#### 1.3.9 Recipe自动备份 参考附件【14】\r\nRecipe自动备份是确保重要数据不丢失的手段。其实现方法是通过FileGee进行的，附件中提供了FileGee使用手册。\r\n目前建立自动备份的方法已经交接给张雪，姜欢欢。请知悉\r\n\r\n### 1.4 智能制造的开发 参考附件【15】\r\n#### 1.4.1 Array智造软件的发布与安装\r\n Array智造是一种CS构架的软件。CS架构是一种较为早期的软件架构模式，大多数的数据处理逻辑与运算是在客户端进行的，这种模式在效率和用户体验上有一定提升，但是每次用户安装和升级需要大量的工作。这里着重介绍一下Array智造软件的发布与安装。\r\n\r\n- 发布采用Visual Stuido自带的OneClick模式（类似于OIC的发布），这样的好处在于安装包存放在服务器或者共享中，提供给用户可以是一个2k的小安装程序。\r\n- 发布时开发者设置好 版本号，运行环境，安装地址后点击发布即可（具体有疑问联系我）\r\n- Array智造采用了 Task.Run（多线程）等.net FrameWork4.5 以上才有的功能，所以Win7电脑安装Array智造时需要先安装 .net FrameWork 4.5即以上  参考附件【16】\r\n\r\n#### 1.4.2 Array智造 开发环境构建\r\n\r\n- Array智造开发工具为 VS（Visual Studio 2017即以上），该软件有微软提供的社区免费版本，百度一下即可\r\n- Array智造选用的主要开发语言为C#，少量功能采用了 前端语言实现（html js css），后续担当简单学习即可，以解决实际工作需求为目的。\r\n- 经过大量对比测试，Array选用的技术框架为 Winform，这是一种比较古老的技术框架，但是适配性好，上手容易。\r\n- UI控件集选用了MetroFramework UI，并且根据其源码进行了一定程度的定制开发。推荐后续担当采用此框架\r\n\r\n#### 1.4.3 Array智造源代码\r\n\r\n- 因为Array智造本质也属于一种比较宝贵的脑力活动资产，源代码保留在我之前使用的科室笔记本电脑中，已经交际给担当 姜欢欢。\r\n#### 1.4.4 智能制造开发所需的一些学习资源  参考附件【17】\r\n\r\n- 编程学习推荐在网易云课堂搜索C#进行学习\r\n- 附件中提供了少量学习资料，多数学习教程存放在 科室笔记本电脑  D盘 学习资料中\r\n- 在Bilibili上也有很多C#语言相关的学习资源\r\n\r\n",
      "data": {
        "title": " 【智能制造之路】智能制造简述",
        "date": "2020-01-22 15:56:31",
        "tags": [
          "智能制造",
          "大数据"
        ],
        "published": true,
        "hideInList": false,
        "feature": "/post-images/zhi-neng-zhi-zao-jian-shu.jpg",
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "zhi-neng-zhi-zao-jian-shu"
    }
  ],
  "tags": [
    {
      "index": -1,
      "name": "智能制造",
      "slug": "smartManufacture",
      "used": true
    },
    {
      "index": -1,
      "name": "python",
      "slug": "python",
      "used": true
    },
    {
      "index": -1,
      "name": "大数据",
      "slug": "bigData",
      "used": true
    },
    {
      "index": -1,
      "name": "代码库",
      "slug": "code",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "分类",
      "openType": "Internal"
    },
    {
      "index": 3,
      "link": "/tag/python/",
      "name": "Python",
      "openType": "Internal"
    },
    {
      "link": "/tag/bigData/",
      "name": "工业与大数据",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tag/code",
      "name": "代码库",
      "openType": "Internal"
    }
  ]
}