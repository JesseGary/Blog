---
title: '【实践数据结构与算法】衡量算法和数据结构的尺子：复杂度计算'
date: 2020-05-27 23:22:48
tags: []
published: true
hideInList: false
feature: 
isTop: false
---
凌晨时分，你写出一段代码，实现了某个算法，优雅如诗。默默在心底说一声：“NB！” 但你知道这注定无人知晓，因为身边早已寂静无声。
但你写的代码是否真的NB？复杂度或许能够解决这个问题。

<!-- more -->

> 学习数据结构与算法，就注定无法绕开复杂度分析。

## 1.为什么需要复杂度分析？
试想，如果不采用复杂度分析，判断一个算法的好最好的方法就是直接将代码跑一遍。但直接运行代码来观察其效率有几个致命的缺点：
1. 事后分析：你不得不把代码写出来才能评估一种算法是否高效
2. 依赖测试环境：测试电脑的配置直接决定了算法的运行时间。
3. 测试结果受到数据规模的影响：不同的算法在不同数据规模下的表现不一致。
   
但是评价算法的执行效率本身就是一种“刚需”，毕竟算法就是为了提升效率，我们向领导汇报的时候，总得需要一个指标来告诉领导我们的价值吧？

所以说，我们需要一种评价方法，能够在事前就大概估算出一个算法的执行效率 。 —— 复杂度

## 2.大O复杂度表示法

如何把算法的效率直观的表达出来呢？我们来看一段代码

```js
function cal(n){
    let sum = 0;
    let i = 1;
    for(; i<=n ; ++i ){
        sum = sum + i
    }
    return sum;
}
```
**复杂度计算是一种粗略的估算，那么我们也就粗略的认为对于计算机来说，执行每一行代码的时间是相同的。**  
我们假设计算机执行一行代码需要的时间为：T。  那么
- 第二行 let sum = 0；需要消耗 T*1；
- 第三行 let i = 1； 需要消耗 T*1；
- for循环将执行N次，每次执行会做执行一次  sum=sum+1 与 ++i ，需要消耗 N * 2T；
- 第七行 return sum；仅仅是一个返回值，并不涉及到数据运算与赋值，不算消耗。
根据以上计算，该算法执行的时间消耗是  **（2N+2）*T**

按照这个思路，下面这段代码

```js
function cal(int n){
    let sum = 0;
    let i = 1;
    for(; i<=n;++i){
        j = 1;
        for(; j <= n ; ++j){
            sum = sum + i * j ;
        }
    }
    return sum;
}
```
为了便于理解，我还是罗嗦的依次分析：
- 第二行，第三行 各消耗一个 T ；
- 外层for循环中 j = 1 与 ++i 总计执行了 2*N次；
- 内层for循环中 sum=sum + i*j 与 ++j 总计执行了  $2N^2$次
- 总计该算法执行消耗了 T(n) =  $2N^2+2N+2(T)$

你有没有发现，无论如何计算，T(n) 与 n有一个比例关系。代码执行次数越多，T(n)与n的比例越大。
我们把这个规律成一个公式

> $T(n) = O(f(n))$

- T(n) 表示代码执行的总时间
- n 表示数据规模的大小
- f(n) 表示代码执行次数的总和
- 公式中O表示代码执行时间T(n)与执行次数f(n) 成正比。

第一个例子就可以写作T(n) = O(2n+2)，第二个例子可以写作 T(n) = O($2n^2$+2n+3)。这就是**大O时间复杂度表示法**

大O的时间复杂度并不是表示具体代码需要执行多久，而是反映了**代码执行时间随着数据规模增大的变化趋势**。所以，也叫**作渐进时间复杂度**（asymptotic time complexity），简称**时间复杂度**。

在时间复杂度计算中，通常我们要把低阶、常量、系数省略掉，毕竟当n很大时，这些因素的影响会变得很小。更重要的是我们毕竟是一种粗略的计算。 

所以，第一个例子可以写作 T(n) = O(n) 第二个例子写作  T(n) = O($n^2$)

确实，就是这么简单。 
![简单.png](https://www.xr1228.com//post-images/1590597451637.png)


## 3.时间复杂度分析

复杂度的定义我们知道了，具体分析一段代码的时间复杂度时有以下几个技巧。

1. 只关注循环次数最多的代码
2. 加法法则：总复杂度等于量级最大的代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

篇幅有限，这里就不罗列代码举例了。多思考，多练习即可。这种入门知识想必难不倒阁下。

>  我亦无他，惟手熟尔。 

下面列举一些常用的复杂度量级，并一一分析。

![](https://www.xr1228.com//post-images/1590598066901.jpg)

#### 1. O(1)
O(1)是常量级的时间复杂度表示方式，并不是说只有一行代码. 只要代码执行时间不随数据量增加变化而变化，即使它有成千上万行代码，其时间复杂度仍然是 O(1)
```
let i =2 ;
let j =3 ;
let sum = i + j ;
```

#### 2. $O(logn)$,$O(n*logn)$






